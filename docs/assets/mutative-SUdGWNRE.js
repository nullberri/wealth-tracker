var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,"name",{value,configurable:!0});const Operation={Remove:"remove",Replace:"replace",Add:"add"},PROXY_DRAFT=Symbol.for("__MUTATIVE_PROXY_DRAFT__"),RAW_RETURN_SYMBOL=Symbol("__MUTATIVE_RAW_RETURN_SYMBOL__"),iteratorSymbol=Symbol.iterator,dataTypes={mutable:"mutable",immutable:"immutable"},internal={};function latest(proxyDraft){var _a;return(_a=proxyDraft.copy)!==null&&_a!==void 0?_a:proxyDraft.original}__name(latest,"latest");function isDraft(target){return!!getProxyDraft(target)}__name(isDraft,"isDraft");function getProxyDraft(value){return typeof value!="object"?null:value==null?void 0:value[PROXY_DRAFT]}__name(getProxyDraft,"getProxyDraft");function getValue(value){var _a;const proxyDraft=getProxyDraft(value);return proxyDraft?(_a=proxyDraft.copy)!==null&&_a!==void 0?_a:proxyDraft.original:value}__name(getValue,"getValue");function isDraftable(value,options){if(!value||typeof value!="object")return!1;let markResult;return Object.getPrototypeOf(value)===Object.prototype||Array.isArray(value)||value instanceof Map||value instanceof Set||!!(options!=null&&options.mark)&&((markResult=options.mark(value,dataTypes))===dataTypes.immutable||typeof markResult=="function")}__name(isDraftable,"isDraftable");function getPath(target,path=[]){if(Object.hasOwnProperty.call(target,"key")){const proxyDraft=getProxyDraft(get(target.parent.copy,target.key));if(proxyDraft!==null&&(proxyDraft==null?void 0:proxyDraft.original)!==target.original)return null;path.push(target.parent.type===3?Array.from(target.parent.setMap.keys()).indexOf(target.key):target.key)}return target.parent?getPath(target.parent,path):path.reverse()}__name(getPath,"getPath");function getType(target){return Array.isArray(target)?1:target instanceof Map?2:target instanceof Set?3:0}__name(getType,"getType");function get(target,key){return getType(target)===2?target.get(key):target[key]}__name(get,"get");function set(target,key,value){getType(target)===2?target.set(key,value):target[key]=value}__name(set,"set");function peek(target,key){const state=getProxyDraft(target);return(state?latest(state):target)[key]}__name(peek,"peek");function isEqual(x,y){return x===y?x!==0||1/x===1/y:x!==x&&y!==y}__name(isEqual,"isEqual");function revokeProxy(proxyDraft){if(proxyDraft)for(;proxyDraft.finalities.revoke.length>0;)proxyDraft.finalities.revoke.pop()()}__name(revokeProxy,"revokeProxy");function escapePath(path,pathAsArray){return pathAsArray?path:[""].concat(path).map(_item=>{const item=`${_item}`;return item.indexOf("/")===-1&&item.indexOf("~")===-1?item:item.replace(/~/g,"~0").replace(/\//g,"~1")}).join("/")}__name(escapePath,"escapePath");function strictCopy(target){const copy=Object.create(Object.getPrototypeOf(target));return Reflect.ownKeys(target).forEach(key=>{let desc=Reflect.getOwnPropertyDescriptor(target,key);if(desc.enumerable&&desc.configurable&&desc.writable){copy[key]=target[key];return}desc.writable||(desc.writable=!0,desc.configurable=!0),(desc.get||desc.set)&&(desc={configurable:!0,writable:!0,enumerable:desc.enumerable,value:target[key]}),Reflect.defineProperty(copy,key,desc)}),copy}__name(strictCopy,"strictCopy");const propIsEnum=Object.prototype.propertyIsEnumerable;function shallowCopy(original,options){let markResult;if(Array.isArray(original))return Array.prototype.concat.call(original);if(original instanceof Set)return new Set(original.values());if(original instanceof Map)return new Map(original);if(options!=null&&options.mark&&(markResult=options.mark(original,dataTypes),markResult!==void 0)&&markResult!==dataTypes.mutable){if(markResult===dataTypes.immutable)return strictCopy(original);if(typeof markResult=="function"){if(options.enablePatches||options.enableAutoFreeze)throw new Error("You can't use mark and patches or auto freeze together.");return markResult()}throw new Error(`Unsupported mark result: ${markResult}`)}else if(typeof original=="object"&&Object.getPrototypeOf(original)===Object.prototype){const copy={};return Object.keys(original).forEach(key=>{copy[key]=original[key]}),Object.getOwnPropertySymbols(original).forEach(key=>{propIsEnum.call(original,key)&&(copy[key]=original[key])}),copy}else throw new Error("Please check mark() to ensure that it is a stable marker draftable function.")}__name(shallowCopy,"shallowCopy");function ensureShallowCopy(target){target.copy||(target.copy=shallowCopy(target.original,target.options))}__name(ensureShallowCopy,"ensureShallowCopy");function deepClone(target){if(!isDraftable(target))return getValue(target);if(Array.isArray(target))return target.map(deepClone);if(target instanceof Map)return new Map(Array.from(target.entries()).map(([k,v])=>[k,deepClone(v)]));if(target instanceof Set)return new Set(Array.from(target).map(deepClone));const copy=Object.create(Object.getPrototypeOf(target));for(const key in target)copy[key]=deepClone(target[key]);return copy}__name(deepClone,"deepClone");function cloneIfNeeded(target){return isDraft(target)?deepClone(target):target}__name(cloneIfNeeded,"cloneIfNeeded");function markChanged(proxyDraft){var _a;proxyDraft.assignedMap=(_a=proxyDraft.assignedMap)!==null&&_a!==void 0?_a:new Map,proxyDraft.operated||(proxyDraft.operated=!0,proxyDraft.parent&&markChanged(proxyDraft.parent))}__name(markChanged,"markChanged");function throwFrozenError(){throw new Error("Cannot modify frozen object")}__name(throwFrozenError,"throwFrozenError");function deepFreeze(target,subKey,updatedValues,stack,keys){{updatedValues=updatedValues??new WeakMap,stack=stack??[],keys=keys??[];const value=updatedValues.has(target)?updatedValues.get(target):target;if(stack.length>0){const index=stack.indexOf(value);if(value&&typeof value=="object"&&index!==-1)throw stack[0]===value?new Error("Forbids circular reference"):new Error(`Forbids circular reference: ~/${keys.slice(0,index).map((key,index2)=>{if(typeof key=="symbol")return`[${key.toString()}]`;const parent=stack[index2];return typeof key=="object"&&(parent instanceof Map||parent instanceof Set)?Array.from(parent.keys()).indexOf(key):key}).join("/")}`);stack.push(value),keys.push(subKey)}else stack.push(value)}if(Object.isFrozen(target)||isDraft(target)){stack.pop(),keys.pop();return}switch(getType(target)){case 2:for(const[key,value]of target)deepFreeze(key,key,updatedValues,stack,keys),deepFreeze(value,key,updatedValues,stack,keys);target.set=target.clear=target.delete=throwFrozenError;break;case 3:for(const value of target)deepFreeze(value,value,updatedValues,stack,keys);target.add=target.clear=target.delete=throwFrozenError;break;case 1:Object.freeze(target);let index=0;for(const value of target)deepFreeze(value,index,updatedValues,stack,keys),index+=1;break;default:Object.freeze(target),Object.keys(target).forEach(name=>{const value=target[name];deepFreeze(value,name,updatedValues,stack,keys)})}stack.pop(),keys.pop()}__name(deepFreeze,"deepFreeze");function has(target,key){return target instanceof Map?target.has(key):Object.prototype.hasOwnProperty.call(target,key)}__name(has,"has");function getDescriptor(target,key){if(key in target){let prototype=Reflect.getPrototypeOf(target);for(;prototype;){const descriptor=Reflect.getOwnPropertyDescriptor(prototype,key);if(descriptor)return descriptor;prototype=Reflect.getPrototypeOf(prototype)}}}__name(getDescriptor,"getDescriptor");function forEach(target,iter){const type=getType(target);if(type===0)Reflect.ownKeys(target).forEach(key=>{iter(key,target[key],target)});else if(type===1){let index=0;for(const entry of target)iter(index,entry,target),index+=1}else target.forEach((entry,index)=>iter(index,entry,target))}__name(forEach,"forEach");function handleValue(target,handledSet){if(isDraft(target)||!isDraftable(target)||handledSet.has(target)||Object.isFrozen(target))return;const isSet=target instanceof Set,setMap=isSet?new Map:void 0;if(handledSet.add(target),forEach(target,(key,value)=>{var _a;if(isDraft(value)){const proxyDraft=getProxyDraft(value);ensureShallowCopy(proxyDraft);const updatedValue=!((_a=proxyDraft.assignedMap)===null||_a===void 0)&&_a.size||proxyDraft.operated?proxyDraft.copy:proxyDraft.original;set(isSet?setMap:target,key,updatedValue)}else handleValue(value,handledSet)}),setMap){const set2=target,values=Array.from(set2);set2.clear(),values.forEach(value=>{set2.add(setMap.has(value)?setMap.get(value):value)})}}__name(handleValue,"handleValue");function finalizeAssigned(proxyDraft,key){const copy=proxyDraft.type===3?proxyDraft.setMap:proxyDraft.copy;proxyDraft.finalities.revoke.length>1&&proxyDraft.assignedMap.get(key)&&copy&&handleValue(get(copy,key),proxyDraft.finalities.handledSet)}__name(finalizeAssigned,"finalizeAssigned");function finalizeSetValue(target){target.type===3&&target.copy&&(target.copy.clear(),target.setMap.forEach(value=>{target.copy.add(getValue(value))}))}__name(finalizeSetValue,"finalizeSetValue");function finalizePatches(target,generatePatches2,patches,inversePatches){if(target.operated&&target.assignedMap&&target.assignedMap.size>0&&!target.finalized){if(patches&&inversePatches){const basePath=getPath(target);basePath&&generatePatches2(target,basePath,patches,inversePatches)}target.finalized=!0}}__name(finalizePatches,"finalizePatches");function markFinalization(target,key,value,generatePatches2){const proxyDraft=getProxyDraft(value);proxyDraft&&(proxyDraft.callbacks||(proxyDraft.callbacks=[]),proxyDraft.callbacks.push((patches,inversePatches)=>{var _a;const copy=target.type===3?target.setMap:target.copy;if(isEqual(get(copy,key),value)){let updatedValue=proxyDraft.original;proxyDraft.copy&&(updatedValue=proxyDraft.copy),finalizeSetValue(target),finalizePatches(target,generatePatches2,patches,inversePatches),target.options.enableAutoFreeze&&(target.options.updatedValues=(_a=target.options.updatedValues)!==null&&_a!==void 0?_a:new WeakMap,target.options.updatedValues.set(updatedValue,proxyDraft.original)),set(copy,key,updatedValue)}}),target.options.enableAutoFreeze&&proxyDraft.finalities!==target.finalities&&(target.options.enableAutoFreeze=!1)),isDraftable(value,target.options)&&target.finalities.draft.push(()=>{const copy=target.type===3?target.setMap:target.copy;isEqual(get(copy,key),value)&&finalizeAssigned(target,key)})}__name(markFinalization,"markFinalization");function generateArrayPatches(proxyState,basePath,patches,inversePatches,pathAsArray){let{original,assignedMap,options}=proxyState,copy=proxyState.copy;copy.length<original.length&&([original,copy]=[copy,original],[patches,inversePatches]=[inversePatches,patches]);for(let index=0;index<original.length;index+=1)if(assignedMap.get(index.toString())&&copy[index]!==original[index]){const _path=basePath.concat([index]),path=escapePath(_path,pathAsArray);patches.push({op:Operation.Replace,path,value:cloneIfNeeded(copy[index])}),inversePatches.push({op:Operation.Replace,path,value:cloneIfNeeded(original[index])})}for(let index=original.length;index<copy.length;index+=1){const _path=basePath.concat([index]),path=escapePath(_path,pathAsArray);patches.push({op:Operation.Add,path,value:cloneIfNeeded(copy[index])})}if(original.length<copy.length){const{arrayLengthAssignment=!0}=options.enablePatches;if(arrayLengthAssignment){const _path=basePath.concat(["length"]),path=escapePath(_path,pathAsArray);inversePatches.push({op:Operation.Replace,path,value:original.length})}else for(let index=copy.length;original.length<index;index-=1){const _path=basePath.concat([index-1]),path=escapePath(_path,pathAsArray);inversePatches.push({op:Operation.Remove,path})}}}__name(generateArrayPatches,"generateArrayPatches");function generatePatchesFromAssigned({original,copy,assignedMap},basePath,patches,inversePatches,pathAsArray){assignedMap.forEach((assignedValue,key)=>{const originalValue=get(original,key),value=cloneIfNeeded(get(copy,key)),op=assignedValue?has(original,key)?Operation.Replace:Operation.Add:Operation.Remove;if(isEqual(originalValue,value)&&op===Operation.Replace)return;const _path=basePath.concat(key),path=escapePath(_path,pathAsArray);patches.push(op===Operation.Remove?{op,path}:{op,path,value}),inversePatches.push(op===Operation.Add?{op:Operation.Remove,path}:op===Operation.Remove?{op:Operation.Add,path,value:originalValue}:{op:Operation.Replace,path,value:originalValue})})}__name(generatePatchesFromAssigned,"generatePatchesFromAssigned");function generateSetPatches({original,copy},basePath,patches,inversePatches,pathAsArray){let index=0;original.forEach(value=>{if(!copy.has(value)){const _path=basePath.concat([index]),path=escapePath(_path,pathAsArray);patches.push({op:Operation.Remove,path,value}),inversePatches.unshift({op:Operation.Add,path,value})}index+=1}),index=0,copy.forEach(value=>{if(!original.has(value)){const _path=basePath.concat([index]),path=escapePath(_path,pathAsArray);patches.push({op:Operation.Add,path,value}),inversePatches.unshift({op:Operation.Remove,path,value})}index+=1})}__name(generateSetPatches,"generateSetPatches");function generatePatches(proxyState,basePath,patches,inversePatches){const{pathAsArray=!0}=proxyState.options.enablePatches;switch(proxyState.type){case 0:case 2:return generatePatchesFromAssigned(proxyState,basePath,patches,inversePatches,pathAsArray);case 1:return generateArrayPatches(proxyState,basePath,patches,inversePatches,pathAsArray);case 3:return generateSetPatches(proxyState,basePath,patches,inversePatches,pathAsArray)}}__name(generatePatches,"generatePatches");let readable=!1;const checkReadable=__name((value,options,ignoreCheckDraftable=!1)=>{if(typeof value=="object"&&value!==null&&(!isDraftable(value,options)||ignoreCheckDraftable)&&!readable)throw new Error("Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.")},"checkReadable"),mapHandler={get size(){return latest(getProxyDraft(this)).size},has(key){return latest(getProxyDraft(this)).has(key)},set(key,value){const target=getProxyDraft(this),source=latest(target);return(!source.has(key)||!isEqual(source.get(key),value))&&(ensureShallowCopy(target),markChanged(target),target.assignedMap.set(key,!0),target.copy.set(key,value),markFinalization(target,key,value,generatePatches)),this},delete(key){if(!this.has(key))return!1;const target=getProxyDraft(this);return ensureShallowCopy(target),markChanged(target),target.original.has(key)?target.assignedMap.set(key,!1):target.assignedMap.delete(key),target.copy.delete(key),!0},clear(){const target=getProxyDraft(this);if(this.size){ensureShallowCopy(target),markChanged(target),target.assignedMap=new Map;for(const[key]of target.original)target.assignedMap.set(key,!1);target.copy.clear()}},forEach(callback,thisArg){const target=getProxyDraft(this);latest(target).forEach((_value,_key)=>{callback.call(thisArg,this.get(_key),_key,this)})},get(key){var _a,_b;const target=getProxyDraft(this),value=latest(target).get(key),mutable=((_b=(_a=target.options).mark)===null||_b===void 0?void 0:_b.call(_a,value,dataTypes))===dataTypes.mutable;if(target.options.strict&&checkReadable(value,target.options,mutable),mutable||target.finalized||!isDraftable(value,target.options)||value!==target.original.get(key))return value;const draft=internal.createDraft({original:value,parentDraft:target,key,finalities:target.finalities,options:target.options});return ensureShallowCopy(target),target.copy.set(key,draft),draft},keys(){return latest(getProxyDraft(this)).keys()},values(){const iterator=this.keys();return{[iteratorSymbol]:()=>this.values(),next:()=>{const result=iterator.next();return result.done?result:{done:!1,value:this.get(result.value)}}}},entries(){const iterator=this.keys();return{[iteratorSymbol]:()=>this.entries(),next:()=>{const result=iterator.next();if(result.done)return result;const value=this.get(result.value);return{done:!1,value:[result.value,value]}}}},[iteratorSymbol](){return this.entries()}},mapHandlerKeys=Reflect.ownKeys(mapHandler),getNextIterator=__name((target,iterator,{isValuesIterator})=>()=>{var _a,_b;const result=iterator.next();if(result.done)return result;const key=result.value;let value=target.setMap.get(key);const currentDraft=getProxyDraft(value),mutable=((_b=(_a=target.options).mark)===null||_b===void 0?void 0:_b.call(_a,value,dataTypes))===dataTypes.mutable;if(target.options.strict&&checkReadable(key,target.options,mutable),!mutable&&!currentDraft&&isDraftable(key,target.options)&&!target.finalized&&target.original.has(key)){const proxy=internal.createDraft({original:key,parentDraft:target,key,finalities:target.finalities,options:target.options});target.setMap.set(key,proxy),value=proxy}else currentDraft&&(value=currentDraft.proxy);return{done:!1,value:isValuesIterator?value:[value,value]}},"getNextIterator"),setHandler={get size(){return getProxyDraft(this).setMap.size},has(value){const target=getProxyDraft(this);if(target.setMap.has(value))return!0;ensureShallowCopy(target);const valueProxyDraft=getProxyDraft(value);return!!(valueProxyDraft&&target.setMap.has(valueProxyDraft.original))},add(value){const target=getProxyDraft(this);return this.has(value)||(ensureShallowCopy(target),markChanged(target),target.assignedMap.set(value,!0),target.setMap.set(value,value),markFinalization(target,value,value,generatePatches)),this},delete(value){if(!this.has(value))return!1;const target=getProxyDraft(this);ensureShallowCopy(target),markChanged(target);const valueProxyDraft=getProxyDraft(value);return valueProxyDraft&&target.setMap.has(valueProxyDraft.original)?(target.assignedMap.set(valueProxyDraft.original,!1),target.setMap.delete(valueProxyDraft.original)):(!valueProxyDraft&&target.setMap.has(value)?target.assignedMap.set(value,!1):target.assignedMap.delete(value),target.setMap.delete(value))},clear(){if(!this.size)return;const target=getProxyDraft(this);ensureShallowCopy(target),markChanged(target);for(const value of target.original)target.assignedMap.set(value,!1);target.setMap.clear()},values(){const target=getProxyDraft(this);ensureShallowCopy(target);const iterator=target.setMap.keys();return{[Symbol.iterator]:()=>this.values(),next:getNextIterator(target,iterator,{isValuesIterator:!0})}},entries(){const target=getProxyDraft(this);ensureShallowCopy(target);const iterator=target.setMap.keys();return{[Symbol.iterator]:()=>this.entries(),next:getNextIterator(target,iterator,{isValuesIterator:!1})}},keys(){return this.values()},[iteratorSymbol](){return this.values()},forEach(callback,thisArg){const iterator=this.values();let result=iterator.next();for(;!result.done;)callback.call(thisArg,result.value,result.value,this),result=iterator.next()}},setHandlerKeys=Reflect.ownKeys(setHandler),proxyHandler={get(target,key,receiver){var _a;if(key===PROXY_DRAFT)return target;let markResult;if(target.options.mark){const value2=key==="size"&&(target.original instanceof Map||target.original instanceof Set)?Reflect.get(target.original,key):Reflect.get(target.original,key,receiver);if(markResult=target.options.mark(value2,dataTypes),markResult===dataTypes.mutable)return target.options.strict&&checkReadable(value2,target.options,!0),value2}const source=latest(target);if(source instanceof Map&&mapHandlerKeys.includes(key)){if(key==="size")return Object.getOwnPropertyDescriptor(mapHandler,"size").get.call(target.proxy);const handle=mapHandler[key];if(handle)return handle.bind(target.proxy)}if(source instanceof Set&&setHandlerKeys.includes(key)){if(key==="size")return Object.getOwnPropertyDescriptor(setHandler,"size").get.call(target.proxy);const handle=setHandler[key];if(handle)return handle.bind(target.proxy)}if(!has(source,key)){const desc=getDescriptor(source,key);return desc?"value"in desc?desc.value:(_a=desc.get)===null||_a===void 0?void 0:_a.call(target.proxy):void 0}const value=source[key];if(target.options.strict&&checkReadable(value,target.options),target.finalized||!isDraftable(value,target.options))return value;if(value===peek(target.original,key)){if(ensureShallowCopy(target),target.copy[key]=createDraft({original:target.original[key],parentDraft:target,key:target.type===1?Number(key):key,finalities:target.finalities,options:target.options}),typeof markResult=="function"){const subProxyDraft=getProxyDraft(target.copy[key]);return ensureShallowCopy(subProxyDraft),markChanged(subProxyDraft),subProxyDraft.copy}return target.copy[key]}return value},set(target,key,value){var _a;if(target.type===3||target.type===2)throw new Error("Map/Set draft does not support any property assignment.");if(target.type===1&&key!=="length"&&isNaN(Number(key)))throw new Error("Only supports setting array indices and the 'length' property.");const desc=getDescriptor(latest(target),key);if(desc!=null&&desc.set)return desc.set.call(target.proxy,value),!0;const current2=peek(latest(target),key),currentProxyDraft=getProxyDraft(current2);return currentProxyDraft&&isEqual(currentProxyDraft.original,value)?(target.copy[key]=value,target.assignedMap=(_a=target.assignedMap)!==null&&_a!==void 0?_a:new Map,target.assignedMap.set(key,!1),!0):(isEqual(value,current2)&&(value!==void 0||has(target.original,key))||(ensureShallowCopy(target),markChanged(target),has(target.original,key)&&isEqual(value,target.original[key])?target.assignedMap.delete(key):target.assignedMap.set(key,!0),target.copy[key]=value,markFinalization(target,key,value,generatePatches)),!0)},has(target,key){return key in latest(target)},ownKeys(target){return Reflect.ownKeys(latest(target))},getOwnPropertyDescriptor(target,key){const source=latest(target),descriptor=Reflect.getOwnPropertyDescriptor(source,key);return descriptor&&{writable:!0,configurable:target.type!==1||key!=="length",enumerable:descriptor.enumerable,value:source[key]}},getPrototypeOf(target){return Reflect.getPrototypeOf(target.original)},setPrototypeOf(){throw new Error("Cannot call 'setPrototypeOf()' on drafts")},defineProperty(){throw new Error("Cannot call 'defineProperty()' on drafts")},deleteProperty(target,key){var _a;return target.type===1?proxyHandler.set.call(this,target,key,void 0,target.proxy):(peek(target.original,key)!==void 0||key in target.original?(ensureShallowCopy(target),markChanged(target),target.assignedMap.set(key,!1)):(target.assignedMap=(_a=target.assignedMap)!==null&&_a!==void 0?_a:new Map,target.assignedMap.delete(key)),target.copy&&delete target.copy[key],!0)}};function createDraft(createDraftOptions){const{original,parentDraft,key,finalities,options}=createDraftOptions,type=getType(original),proxyDraft={type,finalized:!1,parent:parentDraft,original,copy:null,proxy:null,finalities,options,setMap:type===3?new Map(original.entries()):void 0};(key||"key"in createDraftOptions)&&(proxyDraft.key=key);const{proxy,revoke}=Proxy.revocable(type===1?Object.assign([],proxyDraft):proxyDraft,proxyHandler);if(finalities.revoke.push(revoke),proxyDraft.proxy=proxy,parentDraft){const target=parentDraft;target.finalities.draft.push((patches,inversePatches)=>{var _a,_b;const oldProxyDraft=getProxyDraft(proxy);let copy=target.type===3?target.setMap:target.copy;const draft=get(copy,key),proxyDraft2=getProxyDraft(draft);if(proxyDraft2){let updatedValue=proxyDraft2.original;proxyDraft2.operated&&(updatedValue=getValue(draft)),finalizeSetValue(proxyDraft2),finalizePatches(proxyDraft2,generatePatches,patches,inversePatches),target.options.enableAutoFreeze&&(target.options.updatedValues=(_a=target.options.updatedValues)!==null&&_a!==void 0?_a:new WeakMap,target.options.updatedValues.set(updatedValue,proxyDraft2.original)),set(copy,key,updatedValue)}(_b=oldProxyDraft.callbacks)===null||_b===void 0||_b.forEach(callback=>{callback(patches,inversePatches)})})}else{const target=getProxyDraft(proxy);target.finalities.draft.push((patches,inversePatches)=>{finalizeSetValue(target),finalizePatches(target,generatePatches,patches,inversePatches)})}return proxy}__name(createDraft,"createDraft");internal.createDraft=createDraft;function finalizeDraft(result,returnedValue,patches,inversePatches,enableAutoFreeze){var _a;const proxyDraft=getProxyDraft(result),original=(_a=proxyDraft==null?void 0:proxyDraft.original)!==null&&_a!==void 0?_a:result,hasReturnedValue=!!returnedValue.length;if(proxyDraft!=null&&proxyDraft.operated)for(;proxyDraft.finalities.draft.length>0;)proxyDraft.finalities.draft.pop()(patches,inversePatches);const state=hasReturnedValue?returnedValue[0]:proxyDraft?proxyDraft.operated?proxyDraft.copy:proxyDraft.original:result;return proxyDraft&&revokeProxy(proxyDraft),enableAutoFreeze&&deepFreeze(state,state,proxyDraft==null?void 0:proxyDraft.options.updatedValues),[state,patches&&hasReturnedValue?[{op:Operation.Replace,path:[],value:returnedValue[0]}]:patches,inversePatches&&hasReturnedValue?[{op:Operation.Replace,path:[],value:original}]:inversePatches]}__name(finalizeDraft,"finalizeDraft");function draftify(baseState,options){var _a;const finalities={draft:[],revoke:[],handledSet:new WeakSet};let patches,inversePatches;options.enablePatches&&(patches=[],inversePatches=[]);const draft=((_a=options.mark)===null||_a===void 0?void 0:_a.call(options,baseState,dataTypes))===dataTypes.mutable||!isDraftable(baseState,options)?baseState:createDraft({original:baseState,parentDraft:null,finalities,options});return[draft,(returnedValue=[])=>{const[finalizedState,finalizedPatches,finalizedInversePatches]=finalizeDraft(draft,returnedValue,patches,inversePatches,options.enableAutoFreeze);return options.enablePatches?[finalizedState,finalizedPatches,finalizedInversePatches]:finalizedState}]}__name(draftify,"draftify");function handleReturnValue(options){const{rootDraft,value,useRawReturn=!1,isRoot=!0}=options;forEach(value,(key,item,source)=>{const proxyDraft=getProxyDraft(item);if(proxyDraft&&rootDraft&&proxyDraft.finalities===rootDraft.finalities){options.isContainDraft=!0;const currentValue=proxyDraft.original;if(source instanceof Set){const arr=Array.from(source);source.clear(),arr.forEach(_item=>source.add(key===_item?currentValue:_item))}else set(source,key,currentValue)}else typeof item=="object"&&item!==null&&(options.value=item,options.isRoot=!1,handleReturnValue(options))}),isRoot&&(options.isContainDraft||console.warn("The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance."),useRawReturn&&console.warn("The return value contains drafts, please don't use 'rawReturn()' to wrap the return value."))}__name(handleReturnValue,"handleReturnValue");function getCurrent(target){const proxyDraft=getProxyDraft(target);if(!isDraftable(target,proxyDraft==null?void 0:proxyDraft.options))return target;const type=getType(target);if(proxyDraft&&!proxyDraft.operated)return proxyDraft.original;proxyDraft&&(proxyDraft.finalized=!0);let currentValue;try{currentValue=type===2?new Map(target):type===3?Array.from(proxyDraft.setMap.values()):shallowCopy(target,proxyDraft==null?void 0:proxyDraft.options)}finally{proxyDraft&&(proxyDraft.finalized=!1)}return forEach(currentValue,(key,value)=>{proxyDraft&&isEqual(get(proxyDraft.original,key),value)||set(currentValue,key,getCurrent(value))}),type===3?new Set(currentValue):currentValue}__name(getCurrent,"getCurrent");function current(target){if(!isDraft(target))throw new Error(`current() is only used for Draft, parameter: ${target}`);return getCurrent(target)}__name(current,"current");const makeCreator=__name(arg=>{if(arg!==void 0&&Object.prototype.toString.call(arg)!=="[object Object]")throw new Error(`Invalid options: ${String(arg)}, 'options' should be an object.`);return __name(function create2(arg0,arg1,arg2){var _a,_b,_c;if(typeof arg0=="function"&&typeof arg1!="function")return function(base2,...args){return create2(base2,draft2=>arg0.call(this,draft2,...args),arg1)};const base=arg0,mutate=arg1;let options=arg2;if(typeof arg1!="function"&&(options=arg1),options!==void 0&&Object.prototype.toString.call(options)!=="[object Object]")throw new Error(`Invalid options: ${options}, 'options' should be an object.`);options=Object.assign(Object.assign({},arg),options);const state=isDraft(base)?current(base):base,mark=Array.isArray(options.mark)?(value,types)=>{for(const mark2 of options.mark){if(typeof mark2!="function")throw new Error(`Invalid mark: ${mark2}, 'mark' should be a function.`);const result2=mark2(value,types);if(result2)return result2}}:options.mark,enablePatches=(_a=options.enablePatches)!==null&&_a!==void 0?_a:!1,strict=(_b=options.strict)!==null&&_b!==void 0?_b:!1,_options={enableAutoFreeze:(_c=options.enableAutoFreeze)!==null&&_c!==void 0?_c:!1,mark,strict,enablePatches};if(!isDraftable(state,_options)&&typeof state=="object"&&state!==null)throw new Error("Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.");const[draft,finalize]=draftify(state,_options);if(typeof arg1!="function"){if(!isDraftable(state,_options))throw new Error("Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.");return[draft,finalize]}let result;try{result=mutate(draft)}catch(error){throw revokeProxy(getProxyDraft(draft)),error}const returnValue=__name(value=>{const proxyDraft=getProxyDraft(draft);if(!isDraft(value)){if(value!==void 0&&!isEqual(value,draft)&&(proxyDraft!=null&&proxyDraft.operated))throw new Error("Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.");const rawReturnValue=value==null?void 0:value[RAW_RETURN_SYMBOL];if(rawReturnValue){const _value=rawReturnValue[0];return _options.strict&&typeof value=="object"&&value!==null&&handleReturnValue({rootDraft:proxyDraft,value,useRawReturn:!0}),finalize([_value])}if(value!==void 0)return typeof value=="object"&&value!==null&&handleReturnValue({rootDraft:proxyDraft,value}),finalize([value])}if(value===draft||value===void 0)return finalize([]);const returnedProxyDraft=getProxyDraft(value);if(_options===returnedProxyDraft.options){if(returnedProxyDraft.operated)throw new Error("Cannot return a modified child draft.");return finalize([current(value)])}return finalize([value])},"returnValue");return result instanceof Promise?result.then(returnValue,error=>{throw revokeProxy(getProxyDraft(draft)),error}):returnValue(result)},"create")},"makeCreator"),create=makeCreator();Object.prototype.constructor.toString();export{create as c};
//# sourceMappingURL=mutative-SUdGWNRE.js.map
